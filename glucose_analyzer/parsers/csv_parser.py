"""
LibreView CSV Parser
Parses FreeStyle Libre 3 CGM data from LibreView CSV exports
"""

import pandas as pd
from datetime import datetime
from pathlib import Path


class LibreViewParser:
    """Parser for LibreView CSV export files"""
    
    # Column names in LibreView CSV
    COL_DEVICE = "Device"
    COL_SERIAL = "Serial Number"
    COL_TIMESTAMP = "Device Timestamp"
    COL_RECORD_TYPE = "Record Type"
    COL_HISTORIC_GLUCOSE = "Historic Glucose mg/dL"
    COL_SCAN_GLUCOSE = "Scan Glucose mg/dL"
    
    # Record types
    RECORD_TYPE_AUTO = 0      # Automatic 5-minute readings
    RECORD_TYPE_SCAN = 1      # Manual scan readings
    RECORD_TYPE_EVENT = 6     # System events (sensor start/end, gaps)
    
    def __init__(self, filepath):
        """
        Initialize parser with CSV file path
        
        Args:
            filepath: Path to LibreView CSV export file
        """
        self.filepath = Path(filepath)
        self.metadata = {}
        self.data = None
        self._raw_df = None
    
    def parse(self):
        """
        Parse the LibreView CSV file
        
        Returns:
            DataFrame with parsed CGM data
        """
        if not self.filepath.exists():
            raise FileNotFoundError(f"CSV file not found: {self.filepath}")
        
        # Read the entire CSV to handle the metadata header
        with open(self.filepath, 'r') as f:
            lines = f.readlines()
        
        if len(lines) < 2:
            raise ValueError("CSV file is too short - missing header or data")
        
        # Parse metadata from first line
        self._parse_metadata(lines[0])
        
        # Read CSV data starting from line 2 (skip metadata line)
        # Line 1 (index 0) is metadata, Line 2 (index 1) is column headers
        self._raw_df = pd.read_csv(self.filepath, skiprows=1)
        
        # Parse and clean the data
        self.data = self._process_data()
        
        return self.data
    
    def _parse_metadata(self, metadata_line):
        """Parse the metadata header line"""
        parts = [p.strip() for p in metadata_line.split(',')]
        
        # Expected format: "Glucose Data,Generated on,<date>,Generated by,<name>"
        if len(parts) >= 5:
            self.metadata['report_type'] = parts[0]
            self.metadata['generated_on'] = parts[2]
            self.metadata['generated_by'] = parts[4]
    
    def _process_data(self):
        """Process raw DataFrame into clean CGM data structure"""
        df = self._raw_df.copy()
        
        # Convert record type to integer
        df[self.COL_RECORD_TYPE] = pd.to_numeric(df[self.COL_RECORD_TYPE], errors='coerce')
        
        # Parse timestamps
        df['timestamp'] = pd.to_datetime(df[self.COL_TIMESTAMP], format='%m-%d-%Y %I:%M %p')
        
        # Combine historic and scan glucose into single column
        # Type 0 uses Historic, Type 1 uses Scan
        df['glucose'] = df[self.COL_HISTORIC_GLUCOSE].fillna(df[self.COL_SCAN_GLUCOSE])
        df['glucose'] = pd.to_numeric(df['glucose'], errors='coerce')
        
        # Create clean DataFrame with essential columns
        clean_df = pd.DataFrame({
            'timestamp': df['timestamp'],
            'glucose': df['glucose'],
            'record_type': df[self.COL_RECORD_TYPE]
        })
        
        # Remove rows with missing glucose values
        clean_df = clean_df.dropna(subset=['glucose'])
        
        # Sort by timestamp
        clean_df = clean_df.sort_values('timestamp').reset_index(drop=True)
        
        return clean_df
    
    def get_auto_readings(self):
        """
        Get only automatic 5-minute readings (Type 0)
        
        Returns:
            DataFrame with Type 0 records only
        """
        if self.data is None:
            raise ValueError("No data loaded. Call parse() first.")
        
        return self.data[self.data['record_type'] == self.RECORD_TYPE_AUTO].copy()
    
    def get_scan_readings(self):
        """
        Get only manual scan readings (Type 1)
        
        Returns:
            DataFrame with Type 1 records only
        """
        if self.data is None:
            raise ValueError("No data loaded. Call parse() first.")
        
        return self.data[self.data['record_type'] == self.RECORD_TYPE_SCAN].copy()
    
    def get_merged_readings(self):
        """
        Get combined Type 0 and Type 1 readings for higher resolution
        
        Returns:
            DataFrame with both Type 0 and Type 1 records, sorted by timestamp
        """
        if self.data is None:
            raise ValueError("No data loaded. Call parse() first.")
        
        merged = self.data[
            (self.data['record_type'] == self.RECORD_TYPE_AUTO) |
            (self.data['record_type'] == self.RECORD_TYPE_SCAN)
        ].copy()
        
        return merged.sort_values('timestamp').reset_index(drop=True)
    
    def get_date_range(self):
        """
        Get the date range of the data
        
        Returns:
            tuple: (start_datetime, end_datetime)
        """
        if self.data is None:
            raise ValueError("No data loaded. Call parse() first.")
        
        return (self.data['timestamp'].min(), self.data['timestamp'].max())
    
    def get_stats(self):
        """
        Get summary statistics about the parsed data
        
        Returns:
            dict: Statistics including record counts, date range, etc.
        """
        if self.data is None:
            raise ValueError("No data loaded. Call parse() first.")
        
        start_date, end_date = self.get_date_range()
        
        stats = {
            'total_records': len(self.data),
            'type_0_count': len(self.data[self.data['record_type'] == self.RECORD_TYPE_AUTO]),
            'type_1_count': len(self.data[self.data['record_type'] == self.RECORD_TYPE_SCAN]),
            'type_6_count': len(self.data[self.data['record_type'] == self.RECORD_TYPE_EVENT]),
            'start_date': start_date.strftime('%Y-%m-%d %H:%M'),
            'end_date': end_date.strftime('%Y-%m-%d %H:%M'),
            'days_of_data': (end_date - start_date).days,
            'mean_glucose': self.data['glucose'].mean(),
            'min_glucose': self.data['glucose'].min(),
            'max_glucose': self.data['glucose'].max()
        }
        
        return stats


def test_parser():
    """Test function for development"""
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python csv_parser.py <path_to_csv>")
        sys.exit(1)
    
    csv_path = sys.argv[1]
    
    print(f"Parsing: {csv_path}")
    print("-" * 60)
    
    parser = LibreViewParser(csv_path)
    parser.parse()
    
    # Display statistics
    stats = parser.get_stats()
    print(f"\nData Summary:")
    print(f"  Total records: {stats['total_records']}")
    print(f"  Type 0 (auto): {stats['type_0_count']}")
    print(f"  Type 1 (scan): {stats['type_1_count']}")
    print(f"  Type 6 (event): {stats['type_6_count']}")
    print(f"  Date range: {stats['start_date']} to {stats['end_date']}")
    print(f"  Days of data: {stats['days_of_data']}")
    print(f"  Mean glucose: {stats['mean_glucose']:.1f} mg/dL")
    print(f"  Range: {stats['min_glucose']:.0f} - {stats['max_glucose']:.0f} mg/dL")
    
    # Show sample data
    auto_readings = parser.get_auto_readings()
    print(f"\nFirst 5 automatic readings (Type 0):")
    print(auto_readings.head())
    
    print(f"\nLast 5 automatic readings (Type 0):")
    print(auto_readings.tail())


if __name__ == "__main__":
    test_parser()
